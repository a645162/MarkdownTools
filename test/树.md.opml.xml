<?xml version='1.0' encoding='utf-8'?>
<opml version="1.0">
	<head>
		<title>树.md</title>
		<dateCreated>Wed Jun 2023 23:52:16</dateCreated>
		<dateModified>Wed Jun 2023 23:52:16</dateModified>
	</head>
	<body>
		<outline text=" 树.md">
			<outline text="1 树">
				<outline text="1.1 &quot;概念？&quot; '概念！'" _note="这个是用来测试引号用的！&#10;" />
				<outline text="1.2 概念">
					<outline text="1.2.1 树、有序树、二叉树区别" _note="每个结点至多有两棵子树的**有序树**** 并不是** **二叉树**&#10;">
						<outline text="1.2.1.1 树" _note="树是个结点的有限集，结点的孩子没有左右之分。&#10;" />
						<outline text="1.2.1.2 有序树" _note="有序树的孩子的左右子树的次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分左右次序。&#10;" />
						<outline text="1.2.1.3 二叉树" _note="二叉树是一种树形结构，且二叉树是有序树，其主要特征是每个节点至多只能有两棵子树，&#10;并且二叉树的子树有左右之分，其次序不能颠倒，&#10;且无论二叉树其孩子数是否为2，均需确定其左右孩子次序，&#10;即二叉树的结点次序不是相对于另一结点而言的。&#10;" />
					</outline>
					<outline text="1.2.2 某个结点祖先" _note="某个结点上面的所有结点根节点&#10;" />
				</outline>
				<outline text="1.3 树的存储结构" _note="树的存储结构有**双亲表示法**,**孩子表示法**和**孩子兄弟表示法**。&#10;">
					<outline text="1.3.1 孩子兄弟表示法(二叉链表)" _note="左孩子右兄弟&#10;根节点后面没有右子树(不是森林)&#10;```C&#10;typedef struct CSNode{&#10;    ElemType data;&#10;    struct CSNode *firstchild, *nextsibling;&#10;}CSNode, *CSTree;&#10;```&#10;这种表示法，对孩子兄弟表示法的先序遍历等于原树的先序遍历，对孩子兄弟表示法二叉链表的中序遍历等于原树的后序遍历&#10;先-&gt;先&#10;中-&gt;后&#10;" />
					<outline text="1.3.2 资料" _note="https://www.bilibili.com/video/BV1Dg411G7xt&#10;" />
				</outline>
				<outline text="1.4 树的遍历">
					<outline text="1.4.1 树的层次遍历" _note="树的广度优先遍历&#10;层次遍历（用队列实现&#10;①若树非空，则根节点入队&#10;②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队&#10;③重复②直到队列为空&#10;```c&#10;/**&#10; * @brief 层次遍历&#10; *&#10; * @param root&#10; */&#10;void levelOrder(treeNode *root) {&#10;if (NULL == root) return;  // 空树&#10;queue&lt;treeNode *&gt; nodeQueue;  // 创建一个队列保存节点&#10;nodeQueue.push(root);         // 将根节点入队&#10;// 队非空时进行访问&#10;while (!nodeQueue.empty()) {&#10;treeNode *node = nodeQueue.front();            // 取头结点&#10;printf(&quot;%d &quot;, node-&gt;data);                     // 访问节点数据&#10;if (node-&gt;left) nodeQueue.push(node-&gt;left);    // 左子节点入队&#10;if (node-&gt;right) nodeQueue.push(node-&gt;right);  // 右子节点入队&#10;nodeQueue.pop();                               // 头结点出队&#10;}&#10;}&#10;```&#10;" />
					<outline text="1.4.2 特殊的遍历序列">
						<outline text="1.4.2.1 后序遍历序列与中序遍历序列" _note="二叉树在没有右子树的情况下，二叉树的中序和后序序列是相同的。&#10;分析如下：&#10;二叉树的中序序列为：左子树、根、右子树；二叉树的后序序列为：左子树、右子树、根；要想使二叉树的中序和后序序列相同，则只有两种情况可以满足：&#10;1、没有根的二叉树，然而根据二叉树的性质可知，所有的二叉树都有有根节点的，因此此项不满足；&#10;2、没有右子树的二叉树，只有左子树的二叉树，这样二叉树的中序和后序序列都为：左子树、根是满足情况的。&#10;" />
						<outline text="1.4.2.2 先序遍历序列与中序遍历序列相同" _note="只有根结点的二叉树或非叶子结点只有右子树的二叉树&#10;" />
					</outline>
				</outline>
				<outline text="1.5 m叉树" _note="设一颗m叉树中度为0的节点数为$N_0$，度数为1的节点数为$N_1$，...，度数为m的节点数为$N_m$，则$N_0=1+N_2+2N_3+3N_4+...+(m-1)N_m$&#10;[牛客网](https://www.nowcoder.com/questionTerminal/0572ff24ecaf425ba9db2b560c24caab%E2%80%B8)&#10;要注意树中度数（又为边数、指针数）、结点数与叶子结点数之间的关系。&#10;在这里，总结点数：N₀+N₁+N₂+N₃......Nм&#10;总度数为：N₁+2N₂+3N₃......mNм;&#10;总结点数=总度数+1&#10;※很重要※&#10;N₀+N₁+N₂+N₃......Nм = N₁+2N₂+3N₃......mNм + 1&#10;度数加一为总节点个数&#10;N₀ = 1 + N₂ + 2N₃ + (m-1)Nm&#10;设一棵 m 叉树 的结点数为 n ，用多重链表表示其存储结构，则该树中有 **$mn-(n-1)$** 个空指针域。&#10;一棵 m 叉树的结点数为 n，指针域共mn，n结点除根节点外都有一个指针指向，空指针域:mn-(n-1)&#10;" />
				<outline text="1.6 典型题" _note="设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有多少个？&#10;https://blog.csdn.net/l_jd_gululu/article/details/105530290&#10;空树是指树中没有结点的树，空树的度为0，空树的结点数为0，空树的叶子结点数为0。&#10;最小的树是指只有一个根结点的树，最小的树的度为0，最小的树的结点数为1，最小的树的叶子结点数为1。&#10;度为2的树与二叉树的区别：&#10;一棵度为 2 的有序树与一棵二叉树的区别是:度为 2 的树有两个分支,没有左右之分;&#10;一棵二叉树也有两个分支,但有左右之分,且左右不能交换.&#10;度为2的树的结点数至少为3，二叉树的结点数至少为2。&#10;画出有3个节点的树和有3个结点的二叉树的所有不同的形态&#10;![3个节点的树和二叉树](img/3nodetree.png &quot;3个节点的树和二叉树&quot;)&#10;![](img/3nodetree.png)&#10;满足以下条件的二叉树：&#10;（1）先序序列和中序序列相同的二叉树为：**空树**或者任一结点均无左孩子的非空二叉树：&#10;（2）中序序列和后序序列相同的二叉树为：**空树**或者任一结点均无右孩子的非空二叉树：&#10;（3）先序序列和后序序列相同的二叉树为：**空树**或仅有一个结点的二叉树。&#10;不要忘记**空树**这个情况。&#10;设F是一个森林，B是由F转换得到的二叉树，F中有n个非终端结点，则B中右指针域为空的结点有n+1个&#10;每个非终端结点，其所有孩子结点在转换之后，最后一个孩子的右指针也为空&#10;只要是非终端结点，那就有孩子&#10;肯定有一个右指针域为空&#10;再加个根节点右指针域为空&#10;这里考虑一棵树，多棵树的话还得考虑剩下的树&#10;怎么简单怎么考虑&#10;假设在一棵二叉树中，度为2的结点数为15，度为1的结点数为10个，则该二叉树的分支总数为40个&#10;$n_0=1+n_2=16$&#10;15+16+10=41&#10;而根节点没有爹，分之总数可以理解为有爹的结点&#10;41-1=40为分支总数&#10;一颗二叉树的高度为h，所有结点的度为0或2，则这颗二叉树最少有2h-1个结点&#10;左子树有俩孩子，右子树没孩子&#10;序遍历的第一个/最后一个结点问题&#10;若一个二叉树的**树叶**是某子树的**中序遍历序列中的第一个**结点，则它**必是**该子树的**后序遍历序列中的第一个**结点&#10;中 左中右&#10;后 左右中&#10;如果没有限制树叶，那么参考“入”字，的根节点，没有左子树，但是他限制了树叶，所以没有问题&#10;若一个叶子结点是某子树的中序遍历序列的最后一个结点，则它必是孩子树的先序遍历中的最后一个结点。这种说法是否正确？&#10;一个结点是某子树的中序遍历序列的最后一个结点，则它必是孩子树的先序遍历中的最后一个结点，这句话就是错的，&#10;因为该结点可能只有左子树没有右子树，&#10;但题目中强调了叶子结点，那就对了&#10;叶子结点是中序遍历的最后一个结点，则必定是右子树右下角的结点。则也必为先序遍历的最后一个结点。&#10;设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有多少个空指针域？&#10;总的这个指针域m*n，减去非空的数目(注意非根节点的父节点都会消耗一个指针域来指向它，总共n-1个)，所以减一下就是答案&#10;" />
			</outline>
			<outline text="2 图" />
			<outline text="3 搜索" />
			<outline text="4 排序" />
		</outline>
	</body>
</opml>