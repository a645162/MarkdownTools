<?xml version='1.0' encoding='utf-8'?>
<opml version="1.0">
	<head>
		<title>树.md</title>
		<dateCreated>Fri Jun 2023 13:42:16</dateCreated>
		<dateModified>Fri Jun 2023 13:42:16</dateModified>
	</head>
	<body>
		<outline text=" 树.md">
			<outline text="1 树">
				<outline text="1.1 &quot;概念？&quot; '概念！'" _note="&lt;p&gt;这个是用来测试引号用的！&lt;/p&gt;" />
				<outline text="1.2 测试" _note="&lt;p&gt;&lt;strong&gt;加粗&lt;/strong&gt;&#10;&lt;em&gt;倾斜&lt;/em&gt;&#10;~~删除线~~&lt;/p&gt;&#10;&lt;blockquote&gt;&#10;&lt;p&gt;引用&#10;&lt;a href=&quot;http://www.baidu.com&quot;&gt;超链接&lt;/a&gt;&#10;1. 1&#10;2. 2&#10;3. 3&#10;* 1&#10;* 2&#10;* 3&#10;* [ ] 1&#10;* [ ] 2&#10;* [ ] 3&#10;| col1 | col2 | col3 |&#10;| ---- | ---- | ---- |&#10;| 1    | 2    | 3    |&#10;| 4    | 5    | 6    |&lt;/p&gt;&#10;&lt;/blockquote&gt;" />
				<outline text="1.3 概念">
					<outline text="1.3.1 树、有序树、二叉树区别" _note="&lt;p&gt;每个结点至多有两棵子树的&lt;strong&gt;有序树&lt;/strong&gt;&lt;strong&gt; 并不是&lt;/strong&gt; &lt;strong&gt;二叉树&lt;/strong&gt;&lt;/p&gt;">
						<outline text="1.3.1.1 树" _note="&lt;p&gt;树是个结点的有限集，结点的孩子没有左右之分。&lt;/p&gt;" />
						<outline text="1.3.1.2 有序树" _note="&lt;p&gt;有序树的孩子的左右子树的次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分左右次序。&lt;/p&gt;" />
						<outline text="1.3.1.3 二叉树" _note="&lt;p&gt;二叉树是一种树形结构，且二叉树是有序树，其主要特征是每个节点至多只能有两棵子树，&#10;并且二叉树的子树有左右之分，其次序不能颠倒，&#10;且无论二叉树其孩子数是否为2，均需确定其左右孩子次序，&#10;即二叉树的结点次序不是相对于另一结点而言的。&lt;/p&gt;" />
					</outline>
					<outline text="1.3.2 某个结点祖先" _note="&lt;p&gt;某个结点上面的所有结点根节点&lt;/p&gt;" />
				</outline>
				<outline text="1.4 树的存储结构" _note="&lt;p&gt;树的存储结构有&lt;strong&gt;双亲表示法&lt;/strong&gt;,&lt;strong&gt;孩子表示法&lt;/strong&gt;和&lt;strong&gt;孩子兄弟表示法&lt;/strong&gt;。&lt;/p&gt;">
					<outline text="1.4.1 孩子兄弟表示法(二叉链表)" _note="&lt;p&gt;左孩子右兄弟&#10;根节点后面没有右子树(不是森林)&#10;&lt;pre&gt;&lt;code&gt;C&#10;typedef struct CSNode{&#10;    ElemType data;&#10;    struct CSNode *firstchild, *nextsibling;&#10;}CSNode, *CSTree;&lt;/code&gt;&lt;/pre&gt;&#10;这种表示法，对孩子兄弟表示法的先序遍历等于原树的先序遍历，对孩子兄弟表示法二叉链表的中序遍历等于原树的后序遍历&#10;先-&amp;gt;先&#10;中-&amp;gt;后&lt;/p&gt;" />
					<outline text="1.4.2 资料" _note="&lt;p&gt;https://www.bilibili.com/video/BV1Dg411G7xt&lt;/p&gt;" />
				</outline>
				<outline text="1.5 树的遍历">
					<outline text="1.5.1 树的层次遍历" _note="&lt;p&gt;树的广度优先遍历&#10;层次遍历（用队列实现&#10;①若树非空，则根节点入队&#10;②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队&#10;③重复②直到队列为空&#10;&lt;pre&gt;&lt;code&gt;c&#10;/**&#10; * @brief 层次遍历&#10; *&#10; * @param root&#10; */&#10;void levelOrder(treeNode *root) {&#10;if (NULL == root) return;  // 空树&#10;queue&amp;lt;treeNode *&amp;gt; nodeQueue;  // 创建一个队列保存节点&#10;nodeQueue.push(root);         // 将根节点入队&#10;// 队非空时进行访问&#10;while (!nodeQueue.empty()) {&#10;treeNode *node = nodeQueue.front();            // 取头结点&#10;printf(&quot;%d &quot;, node-&amp;gt;data);                     // 访问节点数据&#10;if (node-&amp;gt;left) nodeQueue.push(node-&amp;gt;left);    // 左子节点入队&#10;if (node-&amp;gt;right) nodeQueue.push(node-&amp;gt;right);  // 右子节点入队&#10;nodeQueue.pop();                               // 头结点出队&#10;}&#10;}&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;" />
					<outline text="1.5.2 特殊的遍历序列">
						<outline text="1.5.2.1 后序遍历序列与中序遍历序列" _note="&lt;p&gt;二叉树在没有右子树的情况下，二叉树的中序和后序序列是相同的。&#10;分析如下：&#10;二叉树的中序序列为：左子树、根、右子树；二叉树的后序序列为：左子树、右子树、根；要想使二叉树的中序和后序序列相同，则只有两种情况可以满足：&#10;1、没有根的二叉树，然而根据二叉树的性质可知，所有的二叉树都有有根节点的，因此此项不满足；&#10;2、没有右子树的二叉树，只有左子树的二叉树，这样二叉树的中序和后序序列都为：左子树、根是满足情况的。&lt;/p&gt;" />
						<outline text="1.5.2.2 先序遍历序列与中序遍历序列相同" _note="&lt;p&gt;只有根结点的二叉树或非叶子结点只有右子树的二叉树&lt;/p&gt;" />
					</outline>
				</outline>
				<outline text="1.6 m叉树" _note="&lt;p&gt;设一颗m叉树中度为0的节点数为$N_0$，度数为1的节点数为$N_1$，...，度数为m的节点数为$N_m$，则$N_0=1+N_2+2N_3+3N_4+...+(m-1)N_m$&#10;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/0572ff24ecaf425ba9db2b560c24caab%E2%80%B8&quot;&gt;牛客网&lt;/a&gt;&#10;要注意树中度数（又为边数、指针数）、结点数与叶子结点数之间的关系。&#10;在这里，总结点数：N₀+N₁+N₂+N₃......Nм&#10;总度数为：N₁+2N₂+3N₃......mNм;&#10;总结点数=总度数+1&#10;※很重要※&#10;N₀+N₁+N₂+N₃......Nм = N₁+2N₂+3N₃......mNм + 1&#10;度数加一为总节点个数&#10;N₀ = 1 + N₂ + 2N₃ + (m-1)Nm&#10;设一棵 m 叉树 的结点数为 n ，用多重链表表示其存储结构，则该树中有 &lt;strong&gt;$mn-(n-1)$&lt;/strong&gt; 个空指针域。&#10;一棵 m 叉树的结点数为 n，指针域共mn，n结点除根节点外都有一个指针指向，空指针域:mn-(n-1)&lt;/p&gt;" />
				<outline text="1.7 典型题" _note="&lt;p&gt;设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有多少个？&#10;https://blog.csdn.net/l_jd_gululu/article/details/105530290&#10;空树是指树中没有结点的树，空树的度为0，空树的结点数为0，空树的叶子结点数为0。&#10;最小的树是指只有一个根结点的树，最小的树的度为0，最小的树的结点数为1，最小的树的叶子结点数为1。&#10;度为2的树与二叉树的区别：&#10;一棵度为 2 的有序树与一棵二叉树的区别是:度为 2 的树有两个分支,没有左右之分;&#10;一棵二叉树也有两个分支,但有左右之分,且左右不能交换.&#10;度为2的树的结点数至少为3，二叉树的结点数至少为2。&#10;画出有3个节点的树和有3个结点的二叉树的所有不同的形态&#10;&lt;img alt=&quot;3个节点的树和二叉树&quot; src=&quot;img/3nodetree.png&quot; title=&quot;3个节点的树和二叉树&quot; /&gt;&#10;&lt;img alt=&quot;&quot; src=&quot;img/3nodetree.png&quot; /&gt;&#10;满足以下条件的二叉树：&#10;（1）先序序列和中序序列相同的二叉树为：&lt;strong&gt;空树&lt;/strong&gt;或者任一结点均无左孩子的非空二叉树：&#10;（2）中序序列和后序序列相同的二叉树为：&lt;strong&gt;空树&lt;/strong&gt;或者任一结点均无右孩子的非空二叉树：&#10;（3）先序序列和后序序列相同的二叉树为：&lt;strong&gt;空树&lt;/strong&gt;或仅有一个结点的二叉树。&#10;不要忘记&lt;strong&gt;空树&lt;/strong&gt;这个情况。&#10;设F是一个森林，B是由F转换得到的二叉树，F中有n个非终端结点，则B中右指针域为空的结点有n+1个&#10;每个非终端结点，其所有孩子结点在转换之后，最后一个孩子的右指针也为空&#10;只要是非终端结点，那就有孩子&#10;肯定有一个右指针域为空&#10;再加个根节点右指针域为空&#10;这里考虑一棵树，多棵树的话还得考虑剩下的树&#10;怎么简单怎么考虑&#10;假设在一棵二叉树中，度为2的结点数为15，度为1的结点数为10个，则该二叉树的分支总数为40个&#10;$n_0=1+n_2=16$&#10;15+16+10=41&#10;而根节点没有爹，分之总数可以理解为有爹的结点&#10;41-1=40为分支总数&#10;一颗二叉树的高度为h，所有结点的度为0或2，则这颗二叉树最少有2h-1个结点&#10;左子树有俩孩子，右子树没孩子&#10;序遍历的第一个/最后一个结点问题&#10;若一个二叉树的&lt;strong&gt;树叶&lt;/strong&gt;是某子树的&lt;strong&gt;中序遍历序列中的第一个&lt;/strong&gt;结点，则它&lt;strong&gt;必是&lt;/strong&gt;该子树的&lt;strong&gt;后序遍历序列中的第一个&lt;/strong&gt;结点&#10;中 左中右&#10;后 左右中&#10;如果没有限制树叶，那么参考“入”字，的根节点，没有左子树，但是他限制了树叶，所以没有问题&#10;若一个叶子结点是某子树的中序遍历序列的最后一个结点，则它必是孩子树的先序遍历中的最后一个结点。这种说法是否正确？&#10;一个结点是某子树的中序遍历序列的最后一个结点，则它必是孩子树的先序遍历中的最后一个结点，这句话就是错的，&#10;因为该结点可能只有左子树没有右子树，&#10;但题目中强调了叶子结点，那就对了&#10;叶子结点是中序遍历的最后一个结点，则必定是右子树右下角的结点。则也必为先序遍历的最后一个结点。&#10;设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有多少个空指针域？&#10;总的这个指针域m*n，减去非空的数目(注意非根节点的父节点都会消耗一个指针域来指向它，总共n-1个)，所以减一下就是答案&lt;/p&gt;" />
			</outline>
			<outline text="2 图" />
			<outline text="3 搜索" />
			<outline text="4 排序" />
		</outline>
	</body>
</opml>