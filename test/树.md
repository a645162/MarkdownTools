# 树

## 概念

### 树、有序树、二叉树区别

每个结点至多有两棵子树的**有序树**** 并不是** **二叉树**

#### 树

树是个结点的有限集，结点的孩子没有左右之分。

#### 有序树

有序树的孩子的左右子树的次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分左右次序。

#### 二叉树

二叉树是一种树形结构，且二叉树是有序树，其主要特征是每个节点至多只能有两棵子树，
并且二叉树的子树有左右之分，其次序不能颠倒，
且无论二叉树其孩子数是否为2，均需确定其左右孩子次序，
即二叉树的结点次序不是相对于另一结点而言的。

### 某个结点祖先

某个结点上面的所有结点根节点

## 树的存储结构

树的存储结构有**双亲表示法**,**孩子表示法**和**孩子兄弟表示法**。

### 孩子兄弟表示法(二叉链表)

左孩子右兄弟
根节点后面没有右子树(不是森林)

```C
typedef struct CSNode{
    ElemType data;
    struct CSNode *firstchild, *nextsibling;
}CSNode, *CSTree;
```

这种表示法，对孩子兄弟表示法的先序遍历等于原树的先序遍历，对孩子兄弟表示法二叉链表的中序遍历等于原树的后序遍历

先->先
中->后

### 资料

https://www.bilibili.com/video/BV1Dg411G7xt

## 树的遍历

### 树的层次遍历

树的广度优先遍历

层次遍历（用队列实现
①若树非空，则根节点入队
②若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
③重复②直到队列为空

```c
/**
 * @brief 层次遍历
 *
 * @param root
 */
void levelOrder(treeNode *root) {
if (NULL == root) return;  // 空树

queue<treeNode *> nodeQueue;  // 创建一个队列保存节点
nodeQueue.push(root);         // 将根节点入队

// 队非空时进行访问
while (!nodeQueue.empty()) {
treeNode *node = nodeQueue.front();            // 取头结点
printf("%d ", node->data);                     // 访问节点数据
if (node->left) nodeQueue.push(node->left);    // 左子节点入队
if (node->right) nodeQueue.push(node->right);  // 右子节点入队
nodeQueue.pop();                               // 头结点出队
}
}
```

### 特殊的遍历序列

#### 后序遍历序列与中序遍历序列

二叉树在没有右子树的情况下，二叉树的中序和后序序列是相同的。

分析如下：

二叉树的中序序列为：左子树、根、右子树；二叉树的后序序列为：左子树、右子树、根；要想使二叉树的中序和后序序列相同，则只有两种情况可以满足：

1、没有根的二叉树，然而根据二叉树的性质可知，所有的二叉树都有有根节点的，因此此项不满足；

2、没有右子树的二叉树，只有左子树的二叉树，这样二叉树的中序和后序序列都为：左子树、根是满足情况的。

#### 先序遍历序列与中序遍历序列相同

只有根结点的二叉树或非叶子结点只有右子树的二叉树

## m叉树

设一颗m叉树中度为0的节点数为$N_0$，度数为1的节点数为$N_1$，...，度数为m的节点数为$N_m$，则$N_0=1+N_2+2N_3+3N_4+...+(m-1)N_m$

[牛客网](https://www.nowcoder.com/questionTerminal/0572ff24ecaf425ba9db2b560c24caab%E2%80%B8)

要注意树中度数（又为边数、指针数）、结点数与叶子结点数之间的关系。

在这里，总结点数：N₀+N₁+N₂+N₃......Nм

总度数为：N₁+2N₂+3N₃......mNм;

总结点数=总度数+1

※很重要※
N₀+N₁+N₂+N₃......Nм = N₁+2N₂+3N₃......mNм + 1

度数加一为总节点个数

N₀ = 1 + N₂ + 2N₃ + (m-1)Nm

设一棵 m 叉树 的结点数为 n ，用多重链表表示其存储结构，则该树中有 **$mn-(n-1)$** 个空指针域。

一棵 m 叉树的结点数为 n，指针域共mn，n结点除根节点外都有一个指针指向，空指针域:mn-(n-1)

## 典型题

设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有多少个？
https://blog.csdn.net/l_jd_gululu/article/details/105530290

空树是指树中没有结点的树，空树的度为0，空树的结点数为0，空树的叶子结点数为0。

最小的树是指只有一个根结点的树，最小的树的度为0，最小的树的结点数为1，最小的树的叶子结点数为1。

度为2的树与二叉树的区别：
一棵度为 2 的有序树与一棵二叉树的区别是:度为 2 的树有两个分支,没有左右之分;
一棵二叉树也有两个分支,但有左右之分,且左右不能交换.
度为2的树的结点数至少为3，二叉树的结点数至少为2。

画出有3个节点的树和有3个结点的二叉树的所有不同的形态
![3个节点的树和二叉树](img/3nodetree.png "3个节点的树和二叉树")

![](img/3nodetree.png)

满足以下条件的二叉树：
（1）先序序列和中序序列相同的二叉树为：**空树**或者任一结点均无左孩子的非空二叉树：
（2）中序序列和后序序列相同的二叉树为：**空树**或者任一结点均无右孩子的非空二叉树：
（3）先序序列和后序序列相同的二叉树为：**空树**或仅有一个结点的二叉树。

不要忘记**空树**这个情况。

设F是一个森林，B是由F转换得到的二叉树，F中有n个非终端结点，则B中右指针域为空的结点有n+1个
每个非终端结点，其所有孩子结点在转换之后，最后一个孩子的右指针也为空
只要是非终端结点，那就有孩子
肯定有一个右指针域为空
再加个根节点右指针域为空
这里考虑一棵树，多棵树的话还得考虑剩下的树
怎么简单怎么考虑

假设在一棵二叉树中，度为2的结点数为15，度为1的结点数为10个，则该二叉树的分支总数为40个
$n_0=1+n_2=16$
15+16+10=41
而根节点没有爹，分之总数可以理解为有爹的结点
41-1=40为分支总数

一颗二叉树的高度为h，所有结点的度为0或2，则这颗二叉树最少有2h-1个结点
左子树有俩孩子，右子树没孩子

序遍历的第一个/最后一个结点问题
若一个二叉树的**树叶**是某子树的**中序遍历序列中的第一个**结点，则它**必是**该子树的**后序遍历序列中的第一个**结点

中 左中右
后 左右中

如果没有限制树叶，那么参考“入”字，的根节点，没有左子树，但是他限制了树叶，所以没有问题

若一个叶子结点是某子树的中序遍历序列的最后一个结点，则它必是孩子树的先序遍历中的最后一个结点。这种说法是否正确？
一个结点是某子树的中序遍历序列的最后一个结点，则它必是孩子树的先序遍历中的最后一个结点，这句话就是错的，
因为该结点可能只有左子树没有右子树，
但题目中强调了叶子结点，那就对了
叶子结点是中序遍历的最后一个结点，则必定是右子树右下角的结点。则也必为先序遍历的最后一个结点。

设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有多少个空指针域？
总的这个指针域m*n，减去非空的数目(注意非根节点的父节点都会消耗一个指针域来指向它，总共n-1个)，所以减一下就是答案

# 图

# 搜索

# 排序